#!/usr/bin/python3.9

from past.builtins import execfile
from multiprocessing import Process
from multiprocessing import Lock

import time
import random

# Consume file animalFarm_01.py - generated by running gDSCodeGen on animalFarm_01.dd (take a look at it!)
execfile ('animalFarm_01.py')

#
# For concurrency control
#
TheMasterLock = Lock()
def MasterLock(action):
    if action == "lock":
        TheMasterLock.acquire()
    else:
        TheMasterLock.release()
        
#
# Called by many processes to add (1) animal to a farm
#

def addOneAnimal (farmIndex, animalType, animalNumber):

    # Called by each process, this gets them all running at random times over a 2 to 8 second interval
    time.sleep(random.uniform(2.0, 8.0))
    
    # Add this animal as the "next" one
    animalIndex = gAnimal_AddARowUnderLock(_Type = animalType, _Name = f"{animalType} #{animalNumber}", \
                                           _gFarm_Index = farmIndex, _RowStatus = "")
    
    print (f"Added a {animalType} to {gFarm_Name[farmIndex]}")

##################
# Main - Start by creating the counties and farms statically in mainline code
##################

if __name__ == "__main__":

    # Start with 2 counties
    countyIndexA = gCounty_AddARowUnderLock(_Name = "County A")
    gCounty_Name2Index["County A"] = countyIndexA

    countyIndexB = gCounty_AddARowUnderLock(_Name = "County B")
    gCounty_Name2Index["County B"] = countyIndexB

    # County A has 1 farm and County B has 2 farms
    farmIndexA = gFarm_AddARow(_Name = "Farm A", _gCounty_Index = countyIndexA)

    farmIndexB = gFarm_AddARow(_Name = "Farm B", _gCounty_Index = countyIndexB)

    farmIndexC = gFarm_AddARow(_Name = "Farm C", _gCounty_Index = countyIndexB)

    #
    # Add some animals using a bunch of random processes
    #

    processes = []

    for i in range(3):
        processes.append(Process(target = addOneAnimal, args = (farmIndexA, "Cow", i+1)))
        processes[-1].start()
        processes.append(Process(target = addOneAnimal, args = (farmIndexB, "Cow", i+1)))
        processes[-1].start()
        processes.append(Process(target = addOneAnimal, args = (farmIndexC, "Cow", i+1)))
        processes[-1].start()
        
    for i in range(10):
        processes.append(Process(target = addOneAnimal, args = (farmIndexA, "Chicken", i+1)))
        processes[-1].start()
        processes.append(Process(target = addOneAnimal, args = (farmIndexB, "Chicken", i+1)))
        processes[-1].start()
        processes.append(Process(target = addOneAnimal, args = (farmIndexC, "Chicken", i+1)))
        processes[-1].start()
        
    print ("")
    print (f"Started {len(processes)} processes...")
    print ("")
        
    # Wait for all the processes to complete
    for aProcess in processes:
        aProcess.join()
        
    print ("")
    print ("Done with adding animals!")
    print ("")
    time.sleep(3)

    # Dump all the tables
    gCounty_DumpTable()
    gFarm_DumpTable()
    gAnimal_DumpTable()

    print ("")
    print ("Print information about chickens in County B")
    print ("")
    animalTypeToPrint = "Chicken"
    countyNameToPrint = "County B"

    # For all animals
    for (animalIndex, animalType) in enumerate(gAnimal_Type):
        if animalType == animalTypeToPrint:
            # If correct animal type get farm and county indices
            farmIndex = gAnimal_gFarm_Index[animalIndex]
            countyIndex = gFarm_gCounty_Index[farmIndex]
            # If right county print all information
            if gCounty_Name[countyIndex] == countyNameToPrint:
                print (gCounty_Name[countyIndex],  gFarm_Name[farmIndex], gAnimal_Name[animalIndex])
    print ("")

