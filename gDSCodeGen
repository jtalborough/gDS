#!/usr/bin/python3.9

# Compress tables with indices; mdefine tests for compress
# Shrink tend/raise function routines

import os
import sys
import inspect

LinesToProcess = []                                         # The input file text, line by line
GeneratedCode = ""                                          # The output file text
 
# Return the number of the currently executing line (or comment out) 
def codeLine():
    return ("")
    #return (f"{inspect.currentframe().f_back.f_lineno}: ")

#
# The code below processes the ".dd" files in multiple passes. The goal here is that each pass completes a simple
# check of the ".dd" file's syntax or semantics.
#

#
# Find, process a bit and return the next non-comment line of input text starting at the given line.
#
def getNextLineToProcess(lineIndex):

    primaryKeyword = None
    tokens = [None, None, None, None]

    while (primaryKeyword is None) and (lineIndex < len(LinesToProcess)):
    
        # Get next line
        line = LinesToProcess[lineIndex]
    
        # Split off any comment
        if "#" in line:
            (line, dummy) = line.split("#", 1)
            
        # If something left
        if line != "":
            
            # Split by whitespace
            tokens = line.split()
            
            #print (tokens)
            
            # Add possible missing trailing tokens
            tokens += [None, None, None, None]
            
            # Get primaryKeyword for caller to use
            primaryKeyword = tokens[0]

        # Bump line pointer
        lineIndex += 1
        
    # Note - trailing tokens are the Python None value only if NO text was specified so, if "None" (no quotes)
    # was specified the string "None" (no quotes) will be returned!!
    return (lineIndex, primaryKeyword, tokens[1], tokens[2], tokens[3])
    

#
# Verify keywords belong to the proper set.
#
def verifyKeywords():

    lineIndex = 0

    while lineIndex < len(LinesToProcess):
    
        (lineIndex, primaryKeyword, elementName, arg1, arg2) = getNextLineToProcess(lineIndex)

        if primaryKeyword is not None:
        
            if primaryKeyword not in ("defineTable", "endTable", "defineColumn", "defineIndex", "defineUnary"):
                print (f"{codeLine()}Keyword '{primaryKeyword}' not in vocabulary at line {lineIndex} in the input file")
                exit (1)


#
# Next verify the defineTable/endTable keywords show up in sensible places in the input file.
#
def verifyBeginEndConsistency():
    
    lineIndex = 0
    currentTableName = None

    while lineIndex < len(LinesToProcess):
    
        (lineIndex, primaryKeyword, elementName, arg1, arg2) = getNextLineToProcess(lineIndex)
        
        if primaryKeyword is not None:
        
            if primaryKeyword == "defineTable":
                # If out of sequence
                if currentTableName is not None:
                    print (f"{codeLine()}'defineTable' found before previous table '{currentTableName}' ended at line {lineIndex} in the input file")
                    exit (1)
                    
                # Set up to handle a new table definition
                currentTableName = elementName
                
            elif primaryKeyword == "endTable":
                if currentTableName is None:
                    print (f"{codeLine()}'endTable' found before 'defineTable' at line {lineIndex} in the input file")
                    exit (1)

                # Wipe out table definition
                currentTableName = None
                
            elif primaryKeyword == "defineUnary":
                if currentTableName is not None:
                    print (f"{codeLine()}'defineUnary' found inside table definition at line {lineIndex} in the input file")
                    exit (1)
                
    if currentTableName is not None:
        print (f"{codeLine()}Missing 'endTable' for table '{currentTableName}' at line {lineIndex} in the input file")
        exit (1)
            

#
# Verify the table names do not duplicate. Also ensure table refs make sense.
#
def verifyNoDuplicateTableNamesOrBadRefs():

    lineIndex = 0
    uniqueTableNames = []

    while lineIndex < len(LinesToProcess):
    
        (lineIndex, primaryKeyword, elementName, arg1, arg2) = getNextLineToProcess(lineIndex)

        if primaryKeyword is not None:
        
            if primaryKeyword == "defineTable":
                if elementName in uniqueTableNames:
                    print (f"{codeLine()}'defineTable' defines a duplicate table name '{elementName}' at line {lineIndex} in the input file")
                    exit (1)
                else:
                    uniqueTableNames.append(elementName)

    lineIndex = 0

    while lineIndex < len(LinesToProcess):
    
        (lineIndex, primaryKeyword, elementName, arg1, arg2) = getNextLineToProcess(lineIndex)

        if primaryKeyword is not None:
        
            if primaryKeyword == "defineColumn":
                if elementName.endswith("_Index"):
                    if elementName.count("_") != 2:
                        print (f"{codeLine()}'Index column must be in format '<table>_<table>_Index' at line {lineIndex} in the input file")
                        exit (1)
                    else:
                        (dummy, tableName, dummy) = elementName.split("_")
                        if tableName not in uniqueTableNames:
                            print (f"{codeLine()}'Index column refers to a non-existant table at line {lineIndex} in the input file")
                            exit (1)

#
# Next verify everything between defineTable and endTable starts with the table name.
#
def verifyTableNamePreceedsAll():

    lineIndex = 0
    currentTableName = None

    while lineIndex < len(LinesToProcess):
    
        (lineIndex, primaryKeyword, elementName, arg1, arg2) = getNextLineToProcess(lineIndex)
        
        if primaryKeyword is not None:
        
            if primaryKeyword == "defineTable":
            
                currentTableName = elementName
                
            elif primaryKeyword in ("defineColumn", "defineIndex"):
            
                if not elementName.startswith(f"{currentTableName}_"):
                    print (f"{codeLine()}'defineColumn/Index' element name doesn't start with table name at line {lineIndex} in the input file")
                    exit (1)
                    
            elif primaryKeyword == "endTable":
            
                currentTableName = None


#
# Now verify everything has a Name column somewhere.
#
def verifyNameColumnExists():

    lineIndex = 0
    currentTableName = None

    while lineIndex < len(LinesToProcess):
    
        (lineIndex, primaryKeyword, elementName, arg1, arg2) = getNextLineToProcess(lineIndex)
        
        if primaryKeyword is not None:
        
            if primaryKeyword == "defineTable":
            
                currentTableName = elementName
                nameSeen = False
                
            elif primaryKeyword == "defineColumn":
            
                if elementName == f"{currentTableName}_Name":
                    nameSeen = True
                    
            elif primaryKeyword == "endTable":
            
                if not nameSeen:
                    print (f"{codeLine()}Table '{currentTableName}' doesn't have a Name column at line {lineIndex} in the input file")
                    exit (1)
                
                currentTableName = None


#
# Now verify RowStatus column is last if a lock routine is used.
#
def verifyRowStatusColumnIsLast():

    lineIndex = 0
    currentTableName = None

    while lineIndex < len(LinesToProcess):
    
        (lineIndex, primaryKeyword, elementName, arg1, arg2) = getNextLineToProcess(lineIndex)
        
        if primaryKeyword is not None:
        
            if primaryKeyword == "defineTable":
            
                currentTableName = elementName
                
                rowStatusSeen = False
                lastColumn = False
                
                hasLockRoutine = False
                if arg1 is not None:
                    hasLockRoutine = True
                    
            elif primaryKeyword == "defineColumn":
            
                lastColumn = False
            
                if elementName == f"{currentTableName}_RowStatus":
                    rowStatusSeen = True
                    lastColumn = True
                    
            elif primaryKeyword == "endTable":
            
                #print (f"hasLockRoutine, rowStatusSeen, lastColumn = {hasLockRoutine}, {rowStatusSeen}, {lastColumn}")
            
                if hasLockRoutine:
                    if not (rowStatusSeen and lastColumn):
                        print (f"{codeLine()}Table '{currentTableName}' has a lock routine and doesn't have a RowStatus column last at line {lineIndex} in the input file")
                        exit (1)
                else:
                    if rowStatusSeen:
                        print (f"{codeLine()}Table '{currentTableName}' has no lock routine and has a RowStatus column at line {lineIndex} in the input file")
                        exit (1)
                
                currentTableName = None


#
# Generate the code that defines the global shared variables
#
def generateVariableDefinitions():

    global GeneratedCode

    lineIndex = 0
    currentTableName = None

    # Create start of import file.
    
    GeneratedCode += f"# To consume this file (once only) in a Python program: \n"
    GeneratedCode += f" \n"
    GeneratedCode += f"#     from past.builtins import execfile \n"
    GeneratedCode += f"#     execfile ('<file name>.py') \n"
    GeneratedCode += f" \n"
    GeneratedCode += f"# Start of gDS include file ...\n"
    GeneratedCode += f" \n"
    GeneratedCode += f"from multiprocessing import Manager \n"
    GeneratedCode += f"gDSMgr = Manager() \n"

    while lineIndex < len(LinesToProcess):
    
        (lineIndex, primaryKeyword, elementName, var1, dummy) = getNextLineToProcess(lineIndex)

        if primaryKeyword is not None:
        
            if primaryKeyword == "defineTable":
                currentTableName = elementName
                GeneratedCode += f" \n"
                GeneratedCode += f"# \n"
                GeneratedCode += f"# Define global shared variables for table {currentTableName} \n"
                GeneratedCode += f"# \n"
                
            elif primaryKeyword == "defineColumn":
                GeneratedCode += f"{elementName} = gDSMgr.list() \n"
                
            elif primaryKeyword == "defineUnary":
                GeneratedCode += f" \n"
                GeneratedCode += f"{elementName} = gDSMgr.list() \n"
                GeneratedCode += f"{elementName}.append({var1}) \n"
                
            elif primaryKeyword == "defineIndex":
                GeneratedCode += f"{elementName} = gDSMgr.dict() \n"
                
            elif primaryKeyword == "endTable":
                currentTableName = None

#
# Generate code to create a row with the initial values presented in the column definitions
#
def generateRowAddCode():

    global GeneratedCode
    
    # These walk the input lines to the endTable making dummy args from 
    def addRequiredArgs(lineIndex2):
    
        global GeneratedCode
        
        primaryKeyword = ""
        
        while primaryKeyword != "endTable":
            (lineIndex2, primaryKeyword, elementName, var1, dummy) = getNextLineToProcess(lineIndex2)
            if primaryKeyword == "defineColumn":

                # Only generate required dummy args hene
                if var1 is None:
                    (dummy, columnArgName) = elementName.split("_", 1)
                    GeneratedCode += f"    _{columnArgName},\\\n"

        return

    def addOptionalArgs(lineIndex2):
    
        global GeneratedCode
        
        primaryKeyword = ""
        
        while primaryKeyword != "endTable":
            (lineIndex2, primaryKeyword, elementName, var1, dummy) = getNextLineToProcess(lineIndex2)
            if primaryKeyword == "defineColumn":

                # Only generate required dummy args hene
                if var1 is not None:
                    (dummy, columnArgName) = elementName.split("_", 1)
                    GeneratedCode += f"    _{columnArgName} = {var1},\\\n"

        return

    lineIndex = 0
    currentTableName = None
    currentLockerName = None
    
    while lineIndex < len(LinesToProcess):
    
        (lineIndex, primaryKeyword, elementName, var1, dummy) = getNextLineToProcess(lineIndex)
        
        if primaryKeyword is not None:
        
            if primaryKeyword == "defineTable":
                currentTableName = elementName
                currentLockerName = var1
                
                # Generate header based on having a locker ot not
                if currentLockerName is not None:
                
                    GeneratedCode += f"\n"
                    GeneratedCode += f"# \n"
                    GeneratedCode += f"# Add a row to table {elementName} under lock \n"
                    GeneratedCode += f"# \n"
                    GeneratedCode += f"def {currentTableName}_AddARowUnderLock(\\\n"
                    
                else:
                    
                    GeneratedCode += f"\n"
                    GeneratedCode += f"# \n"
                    GeneratedCode += f"# Add a row to table {elementName} WITHOUT a lock \n"
                    GeneratedCode += f"# \n"
                    GeneratedCode += f"def {currentTableName}_AddARow(\\\n"
                    
                # Generate input arguments
                addRequiredArgs(lineIndex)
                addOptionalArgs(lineIndex)

                GeneratedCode += f"): \n"
                
                # Lock if there is one
                if currentLockerName is not None:
                    GeneratedCode += f"    {currentLockerName}('lock') \n"
                
            # Now create the row based on the input arguments
            elif primaryKeyword == "defineColumn":
                (dummy, columnArgName) = elementName.split("_", 1)
                GeneratedCode += f"    {elementName}.append(_{columnArgName}) \n"
                lastColumnName = elementName
                
            elif primaryKeyword == "defineIndex":
                pass
                
            elif primaryKeyword == "endTable":
                # Get current length (index to this entry) *before* unlocking!!
                GeneratedCode += f"    thisIndex = len({lastColumnName}) - 1 \n"
                
                if currentLockerName is not None:
                    GeneratedCode += f"    {currentLockerName}('unlock') \n"
                    
                GeneratedCode += f"    return (thisIndex) \n"
                
                currentTableName = None
                currentLockerName = None


#
# Generate code to delete all rows in a table where RowStatus is None.
# This is really ugly because doing: "<list> = ..." "de-globals"  the list if it's a gDS list.
#
def generateCompressTableCode():

    global GeneratedCode
    
    # Add the creation of the local temp arrays to the compressor code
    def addTempArrays(lineIndex2):
    
        global GeneratedCode
        
        primaryKeyword = ""
        
        while primaryKeyword != "endTable":
            (lineIndex2, primaryKeyword, elementName, var1, dummy) = getNextLineToProcess(lineIndex2)
            if primaryKeyword == "defineColumn":

                (dummy, columnName) = elementName.split("_", 1)
                # Cretae temporary local columns
                GeneratedCode += f"    _{columnName} = [] \n"
            
            elif primaryKeyword == "defineIndex":
                print (f"{codeLine()}'defineIndex' not supported yet in 'compressor' at line {lineIndex} in the input file")
                exit (1)
                
        return

    # Add code to copy 1 row's column to the temp array
    def addCopyCode(lineIndex2):
    
        global GeneratedCode
        
        primaryKeyword = ""
        
        while primaryKeyword != "endTable":
            (lineIndex2, primaryKeyword, elementName, var1, dummy) = getNextLineToProcess(lineIndex2)
            if primaryKeyword == "defineColumn":

                (dummy, columnName) = elementName.split("_", 1)
                # Copy undeleted columns over to the temporary columns
                GeneratedCode += f"            _{columnName}.append({elementName}[tableIndex]) \n"
                
        return

    # Add code to delete the data in the gDS lists (only way it works)!
    def addDeletegDSDataCode(lineIndex2):
    
        global GeneratedCode
        
        primaryKeyword = ""
        
        while primaryKeyword != "endTable":
            (lineIndex2, primaryKeyword, elementName, var1, dummy) = getNextLineToProcess(lineIndex2)
            if primaryKeyword == "defineColumn":

                # Delete all entries in existing gDSMgr lists (the only way to do this job I'm afraid)
                GeneratedCode += f"    del {elementName}[:] \n"
                
        return

    # Add code to copy 1 row's column to the temp array
    def addCopyBackCode(lineIndex2):
    
        global GeneratedCode
        
        primaryKeyword = ""
        
        while primaryKeyword != "endTable":
            (lineIndex2, primaryKeyword, elementName, var1, dummy) = getNextLineToProcess(lineIndex2)
            if primaryKeyword == "defineColumn":

                # Copy over each column element
                (dummy, columnName) = elementName.split("_", 1)
                GeneratedCode += f"        {elementName}.append(_{columnName}[tableIndex]) \n"
                
        return

    lineIndex = 0
    currentTableName = None
    currentLockerName = None
    
    generateCompressCode = False
    
    while lineIndex < len(LinesToProcess):
    
        (lineIndex, primaryKeyword, elementName, var1, var2) = getNextLineToProcess(lineIndex)
        
        if primaryKeyword is not None:
        
            generateCompressCode = (var1 == "compress") or (var2 == "compress")
                
            if generateCompressCode:
        
                if primaryKeyword == "defineTable":
                
                    currentTableName = elementName
                    currentLockerName = var1
                    
                    GeneratedCode += f"\n"
                    GeneratedCode += f"# \n"
                    GeneratedCode += f"# Delete erased rows in table {elementName} \n"
                    GeneratedCode += f"# \n"
                    GeneratedCode += f"def {currentTableName}_Compress(): \n"
                    GeneratedCode += f"\n"
                            
                    # Add temp lists, 1/table column
                    addTempArrays(lineIndex)

                    GeneratedCode += f"\n"
                    GeneratedCode += f"    for tableIndex in range(len({currentTableName}_RowStatus)): \n"
                    GeneratedCode += f"        if {currentTableName}_RowStatus[tableIndex] is not None: \n"
                    GeneratedCode += f"\n"
                    
                    # Add code to copy the data over if the row's not been not erased
                    addCopyCode(lineIndex)

                    GeneratedCode += f"\n"
                    
                    # Delete all the gDS columns in the table using a "del"
                    addDeletegDSDataCode(lineIndex)
                    
                    # Get ready to copy the data back to the gDS columns (Name should always be there and accurate)
                    GeneratedCode += f"\n"
                    GeneratedCode += f"    for tableIndex in range(len(_RowStatus)): \n"
                    GeneratedCode += f"\n"
                    
                    # And add code to copy temp arrays back
                    addCopyBackCode(lineIndex)

                    GeneratedCode += f"\n"
                    GeneratedCode += f"    return \n"
                    
                # Skip here because we did everything above
                elif primaryKeyword == "defineColumn":
                    pass
                    
                elif primaryKeyword == "defineIndex":
                    pass
                    
                elif primaryKeyword == "endTable":
                    currentTableName = None
                    currentLockerName = None


#
# Generate code to print out the rows in each table for debug
#
def generateTableDumpCode():

    global GeneratedCode

    lineIndex = 0
    currentTableName = None
    currentLockerName = None
    
    while lineIndex < len(LinesToProcess):
    
        (lineIndex, primaryKeyword, elementName, arg1, dummy) = getNextLineToProcess(lineIndex)
        
        if primaryKeyword is not None:
        
            if primaryKeyword == "defineTable":

                currentTableName = elementName
                currentLockerName = arg1

                GeneratedCode += f"\n"
                GeneratedCode += f"# \n"
                GeneratedCode += f"# Print values out for table '{currentTableName}' \n"
                if currentLockerName is not None:
                    GeneratedCode += f"# under lock {currentLockerName} \n"
                GeneratedCode += f"# \n"
                GeneratedCode += f"def {currentTableName}_DumpTable(rangeListToDump = None): \n"
                
                headerGenerated = False
                
            elif primaryKeyword == "defineColumn":
                # If dumping the first column of the table generate a header with information about the table
                if not headerGenerated:
                    headerGenerated = True
                    if currentLockerName is not None:
                        GeneratedCode += f"    {currentLockerName}('lock') \n"
                    GeneratedCode += f"    print (f'**************') \n"
                    GeneratedCode += f"    print (f'**************') \n"
                    GeneratedCode += f"    print ('    Table %24s (using locker = {currentLockerName}) has %d entries' % ('{currentTableName}', len({currentTableName}_Name))) \n"
                    GeneratedCode += f"    print (f'**************') \n"
                    GeneratedCode += f"    print (f'**************') \n"
                    GeneratedCode += f"    print (f'') \n"
                    GeneratedCode += f"    for i in range (0, len({currentTableName}_Name)): \n"
                    GeneratedCode += f"        if (rangeListToDump is None) or (i in rangeListToDump): \n"
                    GeneratedCode += f"            print ('    Row index = %d' % (i)) \n"
                    
                # If an index to another table
                if elementName.endswith("_Index"):
                    # Fail here if the index isn't of the proper form
                    (dummy, nextTableName, dummy) = elementName.split("_", 2)
                    GeneratedCode += f"            print ('    %30s = %10s  (%30s)' % ('{elementName}', {elementName}[i], {nextTableName}_Name[{elementName}[i]])) \n"
                    
                else:
                    GeneratedCode += f"            print ('    %30s = %10s' % ('{elementName}', {elementName}[i])) \n"
                    
            elif primaryKeyword == "defineIndex":
                pass
                
            elif primaryKeyword == "endTable":
                if currentLockerName is not None:
                    GeneratedCode += f"    {currentLockerName}('unlock') \n"
                GeneratedCode += f"    return \n"
                currentTableName = None
                currentLockerName = None
            

###################################
###
### Main
###
###################################

# Get the datastore definition file name prefix
datastoreNamePrefix = sys.argv[1]
if not os.path.exists(datastoreNamePrefix + ".dd"):
    print (f"{codeLine()}File {datastoreNamePrefix + '.dd'} does not exist")
    exit (1)

# Read in the entire datastore definition file
LinesToProcess = open(datastoreNamePrefix + ".dd", "r").read().splitlines()

# Verify all keywords are in our vocabulary
verifyKeywords()

# Verify the table definition start/end keywords match up correctly
verifyBeginEndConsistency()

# Look for duplicate table names
verifyNoDuplicateTableNamesOrBadRefs()

# Verify sub-lines all start with correct table name
verifyTableNamePreceedsAll()

# All tables need a Name column
verifyNameColumnExists()

# If a table lock is given, the RowStatus column must be there and last
verifyRowStatusColumnIsLast()

# Generate code to declare all global shared lists and dictionaries
generateVariableDefinitions()

# Generate code to add a table row when called
generateRowAddCode()

# Generate table compress code if needed (not working right now)
generateCompressTableCode()

# Generate code to print/dump each table's rows when called
generateTableDumpCode()

# Write out the Python file <file name>.py
open(f"{datastoreNamePrefix}.py", "w").write(GeneratedCode)
print (f"Successfully wrote file {datastoreNamePrefix}.py")