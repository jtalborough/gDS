#!/usr/bin/python3.8

import os
import sys

LinesToCompile = []                                         # The input file text 
CompiledText = ""                                           # The output file text

CurrentTable = None                                         # Set by "defineTable" keyword
CurrentTableLock = None                                     # The lock to use to create/dump the table

#
# Find and parse the next non-comment line of text to compile
#
def parseNextLineToCompile(lineIndex):

    primaryKeyword = None
    elementName = None
    var1 = None
    var2 = None

    while (primaryKeyword is None) and (lineIndex < len(LinesToCompile)):
    
        line = LinesToCompile[lineIndex]
    
        if "#" in line:
            (line, dummy) = line.split("#", 1)
            
        if line != "":
            
            tokens = line.split()
 
            if tokens[0] == "defineTable":
                if len(tokens) != 3:
                    print (f"'defineTable' at line {lineIndex + 1} in the input file needs 2 arguments (table name and lock routine name)")
                    print (f"If the lock routine name is 'None' (no quotes) no lock routine is called.")
                    exit (1)
                primaryKeyword = tokens[0]
                elementName = tokens[1]                 # Table name needed
                var1 = tokens[2]                        # The name of the lock routine
            elif tokens[0] == "defineColumn":
                if len(tokens) != 3:
                    print (f"'defineTable' at line {lineIndex + 1} in the input file needs 2 arguments (field name and initial value)")
                    print (f"If the initial value is 'None' (no quotes) the value None is used.")
                    exit (1)
                primaryKeyword = tokens[0]
                elementName = tokens[1]                 # Column name needed
                var1 = tokens[2]                        # Initial column value needed in column definition line
            elif tokens[0] == "defineIndex":
                primaryKeyword = tokens[0]
                elementName = tokens[1]                 # Index name needed in index definition line
            elif tokens[0] == "endTable":
                primaryKeyword = tokens[0]
            else:
                print (f"Invalid primary token '{tokens[0]}' at line {lineIndex + 1} in the input file")
                exit (1)
                
        lineIndex += 1
        
        if var1 == "None":
            var1 = None

    return (lineIndex, primaryKeyword, elementName, var1, var2)
    

#
# Verify the defineTable/endTable and defineColumn/defineIndex keywords make sense in the input file
#
def verifyTableSpecs():
    
    lineIndex = 0
    currentTableName = None
    
    while lineIndex < len(LinesToCompile):
    
        (lineIndex, primaryKeyword, elementName, dummy1, dummy2) = parseNextLineToCompile(lineIndex)
        
        if primaryKeyword == "defineTable":
            if currentTableName is not None:
                print (f"'defineTable' found before previous table '{currentTableName}' ended at line {lineIndex + 1} in the input file")
                exit (1)
            currentTableName = elementName
            columnNameSeen = False
            
        elif primaryKeyword == "endTable":
            if currentTableName is None:
                print (f"'endTable' found before 'defineTable' at line {lineIndex + 1} in the input file")
                exit (1)
            if not columnNameSeen:
                print (f"No '_Name' column defined for table {currentTableName} at line {lineIndex + 1} in the input file")
                exit (1)
            currentTableName = None
            columnNameSeen = False
            
        elif primaryKeyword in ["defineColumn", "defineIndex"]:
            if currentTableName is None:
                print (f"'define...' commands found outside of 'beginTable' block at line {lineIndex + 1} in the input file")
                exit (1)
            else:
                if (primaryKeyword == "defineColumn") and (elementName == f"{currentTableName}_Name"):
                    columnNameSeen = True
                
        else:
            print (f"Unknown primary keyword '{primaryKeyword}' found at line {lineIndex + 1} in the input file")
            exit (1)
            
    if currentTableName is not None:
        print (f"Missing 'endTable' for table '{currentTableName}' at line {lineIndex + 1} in the input file")
        exit (1)
            

#
# Generate the code that defines the global shared variables in the global datastore
#
def generateVariableDefinitions():

    global CompiledText

    lineIndex = 0
    currentTableName = None

    # Create start of import file.
    
    CompiledText += f"# To consume this file (once only) in a Python program: \n"
    CompiledText += f" \n"
    CompiledText += f"#     from past.builtins import execfile \n"
    CompiledText += f"#     execfile ('<file name>.py') \n"
    CompiledText += f" \n"
    CompiledText += f"# Start of gDS include file ...\n"
    CompiledText += f" \n"
    CompiledText += f"from multiprocessing import Manager \n"
    CompiledText += f"gDSMgr = Manager() \n"

    while lineIndex < len(LinesToCompile):
    
        (lineIndex, primaryKeyword, elementName, dummy, dummy) = parseNextLineToCompile(lineIndex)
        
        if primaryKeyword == "defineTable":
            CompiledText += f" \n"
            CompiledText += f"# \n"
            CompiledText += f"# Define global shared variables for table {elementName} \n"
            CompiledText += f"# \n"
            currentTableName = elementName
            
        elif primaryKeyword == "defineColumn":
            CompiledText += f"{elementName} = gDSMgr.list() \n"
            
        elif primaryKeyword == "defineIndex":
            CompiledText += f"{elementName} = gDSMgr.dict() \n"
            
        elif primaryKeyword == "endTable":
            CompiledText += f"{currentTableName}_RowStatus = gDSMgr.list() \n"
            
        else:
            print (f"Unknown primary keyword '{primaryKeyword}' at line {lineIndex + 1} - debug abort)")
            x = 1/0


#
# Generate code to create a row with the initial values presented in the column definitions
#
def generateRowAddCode():

    global CompiledText

    lineIndex = 0
    currentTableName = None
    currentLockerName = None
    
    while lineIndex < len(LinesToCompile):
    
        (lineIndex, primaryKeyword, elementName, var1, dummy) = parseNextLineToCompile(lineIndex)
        
        if primaryKeyword == "defineTable":
            CompiledText += f"\n"
            CompiledText += f"# \n"
            CompiledText += f"# Add a row to table {elementName} under lock (if one was given) \n"
            CompiledText += f"# \n"
            CompiledText += f"def addRow_{elementName}(rowStatus): \n"
            currentTableName = elementName
            currentLockerName = var1
            if currentLockerName is not None:
                CompiledText += f"    {currentLockerName}('lock') \n"
                
        elif primaryKeyword == "defineColumn":
            CompiledText += f"    {elementName}.append({var1}) \n"
            
        elif primaryKeyword == "defineIndex":
            pass
            
        elif primaryKeyword == "endTable":
            # Set row status and get current length (index to this entry) *before* unlocking!!
            CompiledText += f"    {currentTableName}_RowStatus.append(rowStatus) \n"
            CompiledText += f"    thisIndex = len({currentTableName}_RowStatus) - 1 \n"
            if currentLockerName is not None:
                CompiledText += f"    {currentLockerName}('unlock') \n"
            CompiledText += f"    return (thisIndex) \n"
            currentTableName = None
            currentLockerName = None
            
        else:
            print (f"Unknown primary keyword '{primaryKeyword}' at line {lineIndex + 1} - debug abort)")
            x = 1/0
            

#
# Generate code to print out the rows in each table for debug
#
def generateDumpCode():

    global CompiledText

    lineIndex = 0
    currentTableName = None
    currentLockerName = None
    
    while lineIndex < len(LinesToCompile):
    
        (lineIndex, primaryKeyword, elementName, var1, dummy) = parseNextLineToCompile(lineIndex)
        
        if primaryKeyword == "defineTable":

            currentTableName = elementName
            currentLockerName = var1

            CompiledText += f"\n"
            CompiledText += f"# \n"
            CompiledText += f"# Print values out for table '{currentTableName}' \n"
            if currentLockerName is not None:
                CompiledText += f"# under lock {currentLockerName} \n"
            CompiledText += f"# \n"
            CompiledText += f"def dumpTable_{currentTableName}(rangeListToDump = None): \n"
            
            headerGenerated = False
            
        elif primaryKeyword == "defineColumn":
            # If dumping the first column of the table generate a header with information about the table
            if not headerGenerated:
                headerGenerated = True
                if currentLockerName is not None:
                    CompiledText += f"    {currentLockerName}('lock') \n"
                CompiledText += f"    print (f'**************') \n"
                CompiledText += f"    print (f'**************') \n"
                CompiledText += f"    print ('    Table %24s (using locker = {currentLockerName}) has %d entries' % ('{currentTableName}', len({currentTableName}_RowStatus))) \n"
                CompiledText += f"    print (f'**************') \n"
                CompiledText += f"    print (f'**************') \n"
                CompiledText += f"    print (f'') \n"
                CompiledText += f"    for i in range (0, len({currentTableName}_RowStatus)): \n"
                CompiledText += f"        if (rangeListToDump is None) or (i in rangeListToDump): \n"
                CompiledText += f"            print ('    Row index = %d' % (i)) \n"
                
            # If an index to another table
            if elementName.endswith("_Index"):
                # Fail here if the index isn't of the proper form
                (dummy, nextTableName, dummy) = elementName.split("_", 2)
                CompiledText += f"            print ('    %30s = %10s  (%30s)' % ('{elementName}', {elementName}[i], {nextTableName}_Name[{elementName}[i]])) \n"
                
            else:
                CompiledText += f"            print ('    %30s = %10s' % ('{elementName}', {elementName}[i])) \n"
                
        elif primaryKeyword == "defineIndex":
            pass
            
        elif primaryKeyword == "endTable":
            CompiledText += f"            print ('    %30s = %10s' % ('{currentTableName}_RowStatus', {currentTableName}_RowStatus[i])) \n"
            if currentLockerName is not None:
                CompiledText += f"    {currentLockerName}('unlock') \n"
            currentTableName = None
            currentLockerName = None
            
        else:
            print (f"Unknown primary keyword '{primaryKeyword}' at line {lineIndex + 1} - debug abort)")
            x = 1/0
            

###################################
###
### Main
###
###################################

# Get the datastore definition file name prefix
datastoreNamePrefix = sys.argv[1]

# Read in the entire datastore definition file
LinesToCompile = open(datastoreNamePrefix + ".dd", "r").read().splitlines()

# Verify the table definition start/end keywords match up and make sense
verifyTableSpecs()

# Generate code to declare all global shared lists and dictionaries
generateVariableDefinitions()

# Generate code to add a table row when called
generateRowAddCode()

# Generate code to print/dump each table's rows when called
generateDumpCode()

# Write out the Python file <file name>.py
open(f"{datastoreNamePrefix}.py", "w").write(CompiledText)
print (f"Successfully wrote file {datastoreNamePrefix}.py")